void CMAES::CMAESconditioned(std::function<double(vec&)> fitness, vector<std::function<double(vec&)>> constraints, double gamma, vec& xmean, size_t lambda, size_t mu, double sigma, size_t maxeval){
  size_t N = xmean.n_rows, m = constraints.size();

  vec weights = log(mu+0.5)-log(linspace<vec>(1, mu, mu));
  weights /= sum(weights);
  vec tmp = pow(weights,2);
  double mueff = pow(sum(weights),2)/sum(tmp);

  double cc = (4+mueff/N)/(N+4+2.0*mueff/N);
  double cs = (mueff+2)/(N+mueff+5);
  double c1 = 2.0/(pow(N+1.3,2) +mueff);
  double cmu = min(1-c1, 2.0*(mueff-2 +1.0/mueff)/(pow(N+2,2)+mueff));
  double damps = 1 + 2.0*std::max(0.0,sqrt((mueff-1)/(N+1)) -1) +cs;

  vec pc = zeros<vec>(N);
  vec ps = zeros<vec>(N);
  mat B = eye<mat>(N,N);
  vec D = ones<vec>(N);
  mat C = B*diagmat(pow(D,2))*B.t();
  mat invsqrtC = B*diagmat(pow(D,-1))*B.t();
  size_t eigeneval = 0;
  double chiN = pow(N,0.5) * (1-1.0/(4*N)+1.0/(21*pow(N,2)));

  size_t counteval = 0;
  mat arx(N,lambda), armu(N,mu), W(mu,m), cmat(mu,m), imat = zeros<mat>(mu,m);
  vec arfitness(lambda), xtrial(N), xold(N), muC(m), cweights(mu);
  uvec arindex(lambda), infeasindex(mu);
  std::function<double(vec&)> indicator;
  while (counteval < maxeval) {
    for (size_t k = 0; k < lambda; k++) {
      xtrial = xmean + sigma*B*(D%randn<vec>(N));
      arx.col(k) = xtrial;
      arfitness(k) = fitness(xtrial);
      counteval++;
    }

    arindex = sort_index(arfitness);
    armu = arx.cols(arindex.rows(0,mu-1));

    for (size_t j = 0; j < m; j++) {
      indicator = constraints[j];

      for (size_t i = 0; i < mu; i++) {
        xtrial = armu.col(i);
        cmat(i,j) = indicator(xtrial);
        if (cmat(i,j) != 0) {
          imat(i,j) = 1;
        }
      }
      cout << "check.5" << endl;
      muC(j) = sum(imat.col(j));
      cweights = (log(muC(j)+1)-log(linspace<vec>(1, mu, mu)))/(muC(j)*log(muC(j)+1)-sum(log(linspace<vec>(1, N, N))));
      cweights /= sum(weights);
      W.col(j) = cweights;
      cout << "check.5.5" << endl;
    }
    cout << "check1" << endl;
    mat arfeas;
    size_t colcount = 0;
    for (size_t i = 0; i < mu; i++) {
      if (sum(imat.row(i)) == 0) {
        arfeas.insert_cols(colcount,armu.col(i));
        colcount++;
      }
    }
    size_t mufeas = arfeas.n_cols;
    cout << "check2" << endl;
    if (mufeas == 0) { //all mu candidates infeasible
      cout << "check3" << endl;
      // mod C with algorithm 2
      // return to sampling lambda offsprings
      eig_sym(D,B,C);
      D = sqrt(D);

      double top = 0, bot = 0, scale = 0;
      mat moddedEigs = zeros<mat>(N,N);
      for (size_t i = 0; i < N; i++) {
        for (size_t j = 0; j < m; j++) {
          infeasindex = sort_index(cmat.col(j));
          for (size_t l = 0; l < mu; l++) {
            top += imat(l,j)*W(l,j)*dot(armu.col(infeasindex(l))-xmean,B.col(i));
            bot += imat(l,j)*W(l,j);
          }
          scale += top/bot;
          top = 0, bot = 0;
        }
        moddedEigs(i,i) = pow(D(i)*scale,2);
        scale = 0;
      }

      mat S = C - gamma*B*moddedEigs*B.t();
      C = pow(det(C)/det(S),1.0/N)*S;

    } else if (mufeas == mu) { //all mu candidates feasible
      // old algorithm
      cout << "check4" << endl;
      xold = xmean;
      xmean = armu*weights;

      ps = (1-cs)*ps + sqrt(cs*(2-cs)*mueff) * invsqrtC * (xmean-xold)/sigma;
      int hsig = norm(ps)/sqrt(1-pow((1-cs),2.0*counteval/lambda))/chiN < 1.4 + 2.0/(N+1);
      pc = (1-cc)*pc + hsig * sqrt(cc*(2-cc)*mueff) * (xmean-xold)/sigma;

      mat artmp = (1.0/sigma) * (arx.cols(arindex.rows(0,mu-1))-repmat(xold,1,mu));
      C = (1-c1-cmu)*C + c1 * (dot(pc,pc) + (1-hsig)*cc*(2-cc)*C) + cmu*artmp*diagmat(weights)*artmp.t();

      sigma = sigma * exp((cs/damps)*(norm(ps)/chiN - 1));

    } else { //some candidates infeasible
      // mod C with algorithm 2
      // use feasible candiates to update mean
      // use feasible candiates to update C
      cout << "check5" << endl;
      eig_sym(D,B,C);
      D = sqrt(D);

      double top = 0, bot = 0, scale = 0;
      mat moddedEigs = zeros<mat>(N,N);
      for (size_t i = 0; i < N; i++) {
        for (size_t j = 0; j < m; j++) {
          infeasindex = sort_index(cmat.col(j));
          for (size_t l = 0; l < mu; l++) {
            top += imat(l,j)*W(l,j)*dot(armu.col(infeasindex(l))-xmean,B.col(i));
            bot += imat(l,j)*W(l,j);
          }
          scale += top/bot;
          top = 0, bot = 0;
        }
        moddedEigs(i,i) = pow(D(i)*scale,2);
        scale = 0;
      }

      mat S = C - gamma*B*moddedEigs*B.t();
      C = pow(det(C)/det(S),1.0/N)*S;

      xold = xmean;

      vec feasweights = log(mufeas+0.5)-log(linspace<vec>(1, mufeas, mufeas));
      feasweights /= sum(feasweights);
      xmean = arfeas*feasweights;

      ps = (1-cs)*ps + sqrt(cs*(2-cs)*mueff) * invsqrtC * (xmean-xold)/sigma;
      int hsig = norm(ps)/sqrt(1-pow((1-cs),2.0*counteval/lambda))/chiN < 1.4 + 2.0/(N+1);
      pc = (1-cc)*pc + hsig * sqrt(cc*(2-cc)*mueff) * (xmean-xold)/sigma;

      mat artmp = (1.0/sigma) * (arfeas-repmat(xold,1,mufeas));
      C = (1-c1-cmu)*C + c1 * (dot(pc,pc) + (1-hsig)*cc*(2-cc)*C) + cmu*artmp*diagmat(feasweights)*artmp.t();

      sigma = sigma * exp((cs/damps)*(norm(ps)/chiN - 1));
    }
    cout << "check6" << endl;
    if (counteval-eigeneval > lambda/(c1+cmu)/N/10.0) {
      eigeneval = counteval;
      mat utri = trimatu(C);
      cout << "check7" << endl;
      utri.diag().zeros();
      C = trimatu(C) + utri.t();
      cout << "check8" << endl;
      eig_sym(D,B,C);
      cout << "check9" << endl;
      D = sqrt(D);
      invsqrtC = B * diagmat(pow(D,-1)) * B.t();
    }
  }
  vec xbest = arx.col(arindex(1));
  if (fitness(xbest) < fitness(xmean)) {
    xmean = xbest;
  }
}
